import com.fasterxml.jackson.databind.ObjectMapper
import deployments.DockerRegistrySecret
import deployments.IngressRule
import deployments.NotaryDeployment

import java.util.function.BiConsumer

def deployedNamespace = rootProject.ext.'deployed.namespace' as String
def imageSuffix = rootProject.ext.'image.suffix' as String
def hostPrefix = rootProject.ext.'host.prefix' as String

/**
 * Creates a deployment for Auction Network
 * [Networks Services, Notary, Alice, Bob, Charlie]
 */
task buildAuctionNetwork(type: DeploymentTask, dependsOn: ['buildNamespaceAndCreds']) {
    def auctionNetworkServices = kdeployment.buildNMSDeployment.call(
            deployedNamespace,
            "auction-nms",
            nmsImageName
    )
    def auctionNotaryDeployment = NotaryDeployment.buildNotaryDeployment(
            deployedNamespace,
            "auction-notary",
            "roastario/notary-one:5",
            auctionNetworkServices.getNmsService()
    )

    // Node deployment
    ObjectMapper mapper = new ObjectMapper()
    def nodesProperties = new Properties()
    file("$projectDir/azure/nodes.properties").withInputStream { nodesProperties.load(it) }
    List<Iterable<Object>> auctionNodeDeployments = new ArrayList()
    List<IngressRule> ingressRules = new ArrayList()

    nodesProperties.forEach({identifier, nodeSerialized ->
        def node = mapper.readValue(nodeSerialized, Map.class)
        if ((node.get("networks") as List).contains("auction")) {
            println "Configuring ${node.toString()} for deployment."

            def currentNode = kdeployment.buildNodeDeployment.call(
                    ledgerRegCred,
                    deployedNamespace,
                    auctionNetworkServices.nmsService.metadata.name,
                    "auction-$identifier" as String,
                    node.get("x500") as String,
                    gallery_cordapp_docker_image_name as String,
                    imageSuffix as String
            )
            auctionNodeDeployments.add(currentNode)

            // add an ingress rule for routing to service
          ingressRules.add(
                    new IngressRule(
                            hostPrefix + currentNode.getNodeDeployment().metadata.name + ingressHostSuffix,
                            10201,
                            currentNode.nodeService
                    )
          )
        }
    } as BiConsumer<String, String>)

    def auctionIngress = kdeployment.buildIngressDeployment.call(
            deployedNamespace,
            "auction",
            ingressRules
    )

    deployments = [auctionNetworkServices, auctionIngress, auctionNotaryDeployment, *auctionNodeDeployments]
    fileName = "auctionNetworkDeployment"
}

/**
 * Creates a deployment for GBP Network
 * [Networks Services, Notary, Alice, Bob]
 */
task buildGbpNetwork(type: DeploymentTask, dependsOn: ['buildNamespaceAndCreds']) {
    def gbpNetworkServices = kdeployment.buildNMSDeployment.call(
            deployedNamespace,
            "gbp-nms",
            nmsImageName
    )
    def gbpNotaryDeployment = NotaryDeployment.buildNotaryDeployment(
            deployedNamespace as String,
            "gbp-notary",
            "roastario/notary-two:5",
            gbpNetworkServices.getNmsService()
    )

    // Node deployment
    ObjectMapper mapper = new ObjectMapper()
    def nodesProperties = new Properties()
    file("$projectDir/azure/nodes.properties").withInputStream { nodesProperties.load(it) }
    List<Iterable<Object>> gbpNodeDeployments = new ArrayList()
    List<IngressRule> ingressRules = new ArrayList()

    nodesProperties.forEach({identifier, nodeSerialized ->
        def node = mapper.readValue(nodeSerialized, Map.class)
        if ((node.get("networks") as List).contains("gbp")) {
            println "Configuring ${node.toString()} for deployment."

            def currentNode = kdeployment.buildNodeDeployment.call(
                    ledgerRegCred,
                    deployedNamespace as String,
                    gbpNetworkServices.nmsService.metadata.name,
                    "gbp-$identifier",
                    node.get("x500") as String,
                    gallery_cordapp_docker_image_name as String,
                    imageSuffix as String
            )
            gbpNodeDeployments.add(currentNode)

            // add an ingress rule for routing to service
            ingressRules.add(
                    new IngressRule(
                            hostPrefix + currentNode.getNodeDeployment().metadata.name + ingressHostSuffix,
                            10201,
                            currentNode.nodeService
                    )
            )
        }
    } as BiConsumer<String, String>)

    def gbpIngress = kdeployment.buildIngressDeployment.call(
            deployedNamespace as String,
            "gbp",
            ingressRules
    )

    deployments = [gbpNetworkServices, gbpIngress, gbpNotaryDeployment, *gbpNodeDeployments]
    fileName = "gbpNetworkDeployment"
}

/**
 * Creates a deployment for CBDC Network
 * [Networks Services, Notary, Alice, Charlie]
 */
task buildCbdcNetwork(type: DeploymentTask, dependsOn: ['buildNamespaceAndCreds']) {
    def cbdcNetworkServices = kdeployment.buildNMSDeployment.call(
            deployedNamespace,
            "cbdc-nms",
            nmsImageName
    )
    def cbdcNotaryDeployment = NotaryDeployment.buildNotaryDeployment(
            deployedNamespace as String,
            "cbdc-notary",
            "roastario/notary-three:5",
            cbdcNetworkServices.getNmsService()
    )

    // Node deployment
    ObjectMapper mapper = new ObjectMapper()
    def nodesProperties = new Properties()
    file("$projectDir/azure/nodes.properties").withInputStream { nodesProperties.load(it) }
    List<Iterable<Object>> cbdcNodeDeployments = new ArrayList()
    List<IngressRule> ingressRules = new ArrayList()

    nodesProperties.forEach({identifier, nodeSerialized ->
        def node = mapper.readValue(nodeSerialized, Map.class)
        if ((node.get("networks") as List).contains("cbdc")) {
            println "Configuring ${node.toString()} for deployment."

            def currentNode = kdeployment.buildNodeDeployment.call(
                    ledgerRegCred,
                    deployedNamespace as String,
                    cbdcNetworkServices.nmsService.metadata.name,
                    "cbdc-$identifier",
                    node.get("x500") as String,
                    gallery_cordapp_docker_image_name as String,
                    imageSuffix as String
            )
            cbdcNodeDeployments.add(currentNode)

            // add an ingress rule for routing to service
            ingressRules.add(
                    new IngressRule(
                            hostPrefix + currentNode.getNodeDeployment().metadata.name + ingressHostSuffix,
                            10201,
                            currentNode.nodeService
                    )
            )
        }
    } as BiConsumer<String, String>)

    def cbdcIngress = kdeployment.buildIngressDeployment.call(
            deployedNamespace as String,
            "cbdc",
            ingressRules
    )

    deployments = [cbdcNetworkServices, cbdcIngress, cbdcNotaryDeployment, *cbdcNodeDeployments]
    fileName = "cbdcNetworkDeployment"
}

/**
 * Creates deployment for K8s namespace isolation and ACR credentials for pulling docker images
 */
task buildNamespaceAndCreds(type: DeploymentTask) {
    def namespaceDep = kdeployment.buildNamespace(deployedNamespace)
    def acrCredentialsDep = new DockerRegistrySecret(
            deployedNamespace,
            ledgerRegCred,
            docker_push_registry,
            rootProject.ext.'docker.push.username',
            rootProject.ext.'docker.push.password'
    )
    deployments = [namespaceDep, acrCredentialsDep] as Iterable<Object>
    fileName = "namespaceAndCredDeployment"
}

/**
 * Builds all networks in single task
 */
task buildAllNetworks(type: Task, dependsOn: [
        'buildAuctionNetwork',
        'buildGbpNetwork',
        'buildCbdcNetwork'
]) {
    group = "deployment k8s"
}

/**
 * Mid-layer; Frontend and Orchestration Spring services
 */
task buildFrontEndAndSpringService(type: DeploymentTask) {
    def springService = kdeployment.buildWebAppDeployment.call(
            ledgerRegCred,
            deployedNamespace,
            "gallery",
            gallery_webappapi_docker_image_name as String,
            imageSuffix as String,
            [ // environment variables for application.properties overrides
                    "RPC_USERNAME": "rpcUser",
                    "RPC_PASSWORD": "test",
                    "AUCTION_ALICE_RPC_URL": "auction-alice-node:10201",
                    "AUCTION_BOB_RPC_URL": "auction-bob-node:10201",
                    "AUCTION_CHARLIE_RPC_URL": "auction-charlie-node:10201",
                    "GBP_ALICE_RPC_URL": "gbp-alice-node:10201",
                    "GBP_BOB_RPC_URL": "gbp-bob-node:10201",
                    "CBDC_ALICE_RPC_URL": "cbdc-alice-node:10201",
                    "CBDC_CHARLIE_RPC_URL": "cbdc-charlie-node:10201"
            ]
    )
    def frontEnd = kdeployment.buildFrontEndDeployment.call(
            ledgerRegCred as String,
            deployedNamespace as String,
            "gallery",
            frontend_docker_image_name as String,
            imageSuffix as String
    )

    // create ingress rules for web and front-end
    List<IngressRule> ingressRules = new ArrayList()
    ingressRules.add(
            new IngressRule(
                    hostPrefix + springService.getWebAppDeployment().metadata.name + ingressHostSuffix,
                    80,
                    springService.webAppService
            )
    )
    ingressRules.add(
            new IngressRule(
                    hostPrefix + "swaps" + ingressHostSuffix,
                    80,
                    frontEnd.frontEndService
            )
    )
    def frontEndIngress = kdeployment.buildIngressDeployment.call(
        deployedNamespace as String,
        "frontend",
        ingressRules
    )
    deployments = [springService, frontEnd, frontEndIngress] as Iterable<Object>
    fileName = "frontEndAndSpring"
}

/**
 * Top level task to generate yaml for all services.
 */
task buildAll(type: Task, dependsOn: [
        'buildNamespaceAndCreds',
        'buildAllNetworks',
        'buildFrontEndAndSpringService',
        'buildMockFrontEndAndSpringService'
]) {
    group = "deployment k8s"
}

/**
 * Parallel Spring-Mock deployment
 */
task buildMockFrontEndAndSpringService(type: DeploymentTask) {
    def springService = kdeployment.buildWebAppDeployment.call(
            ledgerRegCred,
            deployedNamespace,
            "mock-gallery",
            gallery_webappapi_docker_image_name as String,
            imageSuffix as String,
            [ // environment variables for application.properties overrides
              "RPC_USERNAME": "rpcUser",
              "RPC_PASSWORD": "test",
              "AUCTION_ALICE_RPC_URL": "auction-alice-node:10201",
              "AUCTION_BOB_RPC_URL": "auction-bob-node:10201",
              "AUCTION_CHARLIE_RPC_URL": "auction-charlie-node:10201",
              "GBP_ALICE_RPC_URL": "gbp-alice-node:10201",
              "GBP_BOB_RPC_URL": "gbp-bob-node:10201",
              "CBDC_ALICE_RPC_URL": "cbdc-alice-node:10201",
              "CBDC_CHARLIE_RPC_URL": "cbdc-charlie-node:10201",
              "MOCK_CONTROLLER_ENABLED": "true"
            ]
    )

    def webappApiTargetHost = hostPrefix + springService.getWebAppDeployment().metadata.name + ingressHostSuffix
    def frontendTargetHost = "mock" + hostPrefix + "swaps" + ingressHostSuffix

    def frontEnd = kdeployment.buildFrontEndDeployment.call(
            ledgerRegCred as String,
            deployedNamespace as String,
            "mock-gallery",
            mock_frontend_docker_image_name as String,
            imageSuffix as String
    )

    // create ingress rules for web and front-end
    List<IngressRule> ingressRules = new ArrayList()
    ingressRules.add(
            new IngressRule(
                    webappApiTargetHost,
                    80,
                    springService.webAppService
            )
    )
    ingressRules.add(
            new IngressRule(
                    frontendTargetHost,
                    80,
                    frontEnd.frontEndService
            )
    )
    def frontEndIngress = kdeployment.buildIngressDeployment.call(
            deployedNamespace as String,
            "mock-frontend",
            ingressRules
    )
    deployments = [springService, frontEnd, frontEndIngress] as Iterable<Object>
    fileName = "mockFrontEndAndSpring"
}